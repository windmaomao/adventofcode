# AoC 2015 Javascript - Day 7

## Some Assembly Required

```fortran
lf AND lq -> ls
iu RSHIFT 1 -> jn
bo OR bu -> bv
gj RSHIFT 1 -> hc
et RSHIFT 2 -> eu
```

---

### Model

```javascript
const extractEqn = str => {
  const vars = str.scan(/[a-z]+/g)
  const nums = str.scan(/\d+/g)
  const ops = str.scan(/[A-Z]+/g)
  const name = vars.pop()
  return { ops, vars, nums, name }
}

const eqnMaps = eqns => {
  const maps = {}
  eqns.forEach(eqn => {
    maps[eqn.name] = eqn
  })
  return maps
}
```

Parse the string into equations.

```javascript
const sortDeps = (maps, root) => {
  const processing = {}
  const visited = []

  function visit(node) {
    if (visited.indexOf(node) >= 0) return

    processing[node] = true

    const children = maps[node].vars
    for (const n of children) {
      if (!processing[n] && maps[n]) visit(n)
    }
    for (const n of children) {
      if (visited.indexOf(n) < 0) visited.push(n)
    }
  }

  visit(root)
  visited.push(root)
  return visited
}
```

### Part 1

```javascript
const expr = (vals, eqn) => {
  const { ops, vars, nums } = eqn
  const vs = vars.map(v => vals[v])
  const res = (op) => {
    switch(op) {
      case 'AND': return vs[0] & vs[1]
      case 'OR': return vs[0] | vs[1]
      case 'LSHIFT': return vs[0] << nums[0]
      case 'RSHIFT': return vs[0] >> nums[0]
      case 'NOT': return ~vs[0]
    }
  }
  if (ops.length) return res(ops[0]).mod(65536)
  if (nums.length) return nums[0]
  return vs[0]
}

const part1 = (eqnsMap, depsEqn) => depsEqn
  .reduce((acc, e) => { acc[e.name] = expr(acc, e) }, {})
  .pluck('a')
}
```

